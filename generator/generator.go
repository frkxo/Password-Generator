package generator

import (
	"crypto/rand"
	"errors"
	"math/big"
	"strings"
)

const (
	WeakLength uint = 8 // For weak length passwords

	MedLength uint = 12 // For medium length passwords

	StrongLength uint = 24 // For strong length passwords

	MonsterLength uint = 36 // For very strong length passwords

	// Default letters if user does not specifies specific letters.
	DefaultLetters = "abcdefghijklmnopqrstuvwxyz"

	DefaultAmbiguousLetters = "ijlo" // Similars

	// Default numbers if user does not specifies specific numbers.
	DefaultNumbers = "0123456789"

	DefaultAmbiguousNumbers = "01" // Similars

	/* Default symbols if user does not specifies specific symbols.
	Such as ~` */
	DefaultSymbols = "!$%^&*()_+{}:@[];'#<>?,./|\\-=?"

	DefaultAmbiguousSymbols = "<>[](){}:;'/|\\," // Similars
)

var (
	/*That is the default config if user does not specifies anything.
	Length = 24
	Include everything.
	Exclude ambiguous and similar characters.
	*/
	DefaultConfig = Config{
		Length:                     StrongLength,
		IncludeSymbols:             true,
		IncludeNumbers:             true,
		IncludeUppercaseLetters:    true,
		IncludeLowercaseLetters:    true,
		ExcludeSimilarCharacters:   true,
		ExcludeAmbiguousCharacters: true,
	}

	// ErrConfigIsEmpty is the error if the config is empty.
	ErrConfigIsEmpty = errors.New("Config is empty")
)

type Config struct {
	// Length is the length of the password that generated by the program.
	Length uint

	// CharacterSet is the setting that manually set by the user.
	CharacterSet string

	// User choice whether user includes symbols or not.
	IncludeSymbols bool

	// User choice whether user includes numbers or not.
	IncludeNumbers bool

	// User choice whether user includes uppercase letters or not.
	IncludeUppercaseLetters bool

	// User choice whether user includes lowercase letters or not.
	IncludeLowercaseLetters bool

	/* ExcludeSimilarCharacter is the setting to exclude characters that look
	the same in the characters.*/
	ExcludeSimilarCharacters bool

	/* ExcludeAmbiguousCharacters is the setting to exclude characters that
	hard to remember.*/
	ExcludeAmbiguousCharacters bool
}

// Generates the passwords.
type Generator struct {
	*Config
}

func NewGenerator(config *Config) (*Generator, error) {
	if config == nil {
		config = &DefaultConfig
	}

	if !config.IncludeNumbers &&
		!config.IncludeLowercaseLetters &&
		!config.IncludeUppercaseLetters &&
		!config.IncludeSymbols &&
		config.CharacterSet == "" {
		return nil, ErrConfigIsEmpty
	}

	if config.Length == 0 {
		config.Length = StrongLength
	}

	if config.CharacterSet == "" {
		config.CharacterSet = MakeCharacterSet(config)
	}
	return &Generator{Config: config}, nil
}

func MakeCharacterSet(config *Config) string {
	var characterSet string

	if config.IncludeLowercaseLetters {
		characterSet += DefaultLetters
		if config.ExcludeSimilarCharacters {
			characterSet = removeCharacters(characterSet, DefaultAmbiguousLetters)
		}
	}

	if config.IncludeSymbols {
		characterSet += DefaultSymbols
		if config.ExcludeAmbiguousCharacters {
			characterSet = removeCharacters(characterSet, DefaultAmbiguousSymbols)
		}
	}

	if config.IncludeNumbers {
		characterSet += DefaultNumbers
		if config.ExcludeSimilarCharacters {
			characterSet = removeCharacters(characterSet, DefaultAmbiguousNumbers)
		}
	}

	if config.IncludeUppercaseLetters {
		characterSet += strings.ToUpper(DefaultLetters)
		if config.ExcludeSimilarCharacters {
			characterSet = removeCharacters(characterSet, strings.ToUpper(DefaultAmbiguousLetters))
		}
	}

	return characterSet
}

func removeCharacters(str, characters string) string {
	return strings.Map(func(r rune) rune {
		if !strings.ContainsRune(characters, r) {
			return r
		}
		return -1
	}, str)
}

// New generator with the default config.
func NewDefault() (*Generator, error) {
	return NewGenerator(&DefaultConfig)
}

// Just one password with the length in the config.
func (g Generator) Generate() (*string, error) {
	var generated string

	characterSet := strings.Split(g.Config.CharacterSet, "")
	max := big.NewInt(int64(len(characterSet)))

	for i := uint(0); i < g.Config.Length; i++ {
		val, err := rand.Int(rand.Reader, max)
		if err != nil {
			return nil, err
		}
		generated += characterSet[val.Int64()]
	}
	return &generated, nil
}

// Generates multiple passwords.
func (g Generator) MultipleGenerator(amount uint) ([]string, error) {
	var generated []string

	for i := uint(0); i < amount; i++ {
		str, err := g.Generate()
		if err != nil {
			return nil, err
		}
		generated = append(generated, *str)
	}
	return generated, nil
}

// Generate one password with the length that set by the user.
func (g Generator) GenerateWithLength(length uint) (*string, error) {
	var generated string
	characterSet := strings.Split(g.Config.CharacterSet, "")
	max := big.NewInt(int64(len(characterSet)))

	for i := uint(0); i < length; i++ {
		val, err := rand.Int(rand.Reader, max)
		if err != nil {
			return nil, err
		}
		generated += characterSet[val.Int64()]
	}
	return &generated, nil
}

// Generates many passwords with the length that set by the user.
func (g Generator) MultipleGeneratorWithLength(amount, length uint) ([]string, error) {
	var generated []string

	for i := uint(0); i < amount; i++ {
		str, err := g.GenerateWithLength(length)
		if err != nil {
			return nil, err
		}
		generated = append(generated, *str)
	}
	return generated, nil
}
